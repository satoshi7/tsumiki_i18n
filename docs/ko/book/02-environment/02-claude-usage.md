# 2.2 Claude Sonnet 4의 활용 방법

AITDD의 핵심이 되는 Claude Sonnet 4의 효과적인 활용 방법에 대해 설명합니다. 단순히 AI에게 코드를 작성하게 하는 것이 아니라, 인간과 AI가 협력하여 고품질 소프트웨어를 개발하는 방법을 배웁니다.

## Claude Sonnet 4의 특징과 강점

### AITDD에서의 위치
- **Red-Green-Refactor-Validation 사이클의 실행 주체**
- **설계부터 테스트, 구현까지 일관되게 담당**
- **고품질 코드 생성과 품질 체크를 양립**

### 선택 이유
- **접근성**: Claude Code로 자유롭게 사용 가능
- **코딩 성능**: 필요충분한 수준의 안정된 성능
- **비용 효율성**: 합당한 수준의 비용 ($20/월)
- **AITDD 적합성**: 시행착오 중시 개발 스타일에 최적
- **통합성**: VS Code 환경과의 우수한 연계

## Claude Code의 기본적인 사용법

### 시작과 기본 조작

1. **Claude Code 시작**
   ```bash
   # VS Code 내에서 Claude Code 시작
   # 또는 브라우저 버전 Claude를 통해 접근
   ```

2. **프로젝트와의 연계**
   - 프로젝트 디렉토리 지정
   - 파일 구조 인식
   - 기존 코드 이해

### AITDD에서의 기본적인 대화 패턴

#### 1. 목표 설정 단계
```
당신: "사용자 관리 기능의 CRUD 조작을 구현하고 싶습니다. 먼저 TODO 리스트를 작성해주세요."

Claude: "사용자 관리 기능의 TODO 리스트를 작성합니다:
1. 사용자 모델 정의
2. 사용자 생성 테스트 케이스 작성
3. 사용자 생성 기능 구현
..."
```

#### 2. 테스트 작성 단계
```
당신: "TODO의 첫 번째 항목의 테스트 케이스를 작성해주세요."

Claude: "사용자 모델의 테스트 케이스를 작성합니다:
```javascript
describe('User Model', () => {
  test('should create user with valid data', () => {
    // 테스트 코드
  });
});
```"
```

#### 3. 구현 단계
```
당신: "이 테스트를 통과시키기 위한 코드를 구현해주세요."

Claude: "테스트를 통과시키기 위한 사용자 모델을 구현합니다:
```javascript
class User {
  constructor(name, email) {
    // 구현 코드
  }
}
```"
```

## 효과적인 프롬프트 설계

### 프롬프트 설계의 기본 원칙

#### 1. 명확한 목표 설정
**좋은 예:**
```
"사용자 등록 API (POST /users)를 구현하고 싶습니다.
- 검증 기능 포함
- 에러 핸들링 포함
- 테스트 퍼스트로 진행하고 싶습니다"
```

**나쁜 예:**
```
"사용자 기능을 만들어줘"
```

#### 2. 문맥 제공
```
"현재 프로젝트 구성:
- Express.js + MongoDB
- Jest for testing
- 기존 User 모델 있음

새로 추가하고 싶은 기능:
- 사용자 프로필 업데이트 API"
```

#### 3. 제약 조건 명시
```
"제약 조건:
- 기존 API와의 호환성 유지
- 보안을 고려한 구현
- 성능 요구사항: 1초 이내 응답"
```

### 프롬프트 최적화의 반복 프로세스

#### 단계 1: 초기 실행
1. **프롬프트 작성**
2. **AI에게 실행 의뢰**
3. **결과 평가**

#### 단계 2: 평가와 개선
1. **기대와의 차이점 특정**
2. **프롬프트의 문제점 분석**
3. **개선판 프롬프트 설계**

#### 단계 3: 재실행
1. **개선된 프롬프트로 실행**
2. **결과의 개선도 확인**
3. **필요시 추가 조정**

### 실용적인 프롬프트 템플릿

#### 기능 구현용 템플릿
```
【구현 의뢰】
기능: [구체적인 기능명]
기술 스택: [사용 기술 나열]
요구사항:
- [요구사항1]
- [요구사항2]
- [요구사항3]

제약:
- [제약1]
- [제약2]

기대하는 결과물:
- 테스트 케이스
- 구현 코드
- 문서 (필요시)
```

#### 디버깅용 템플릿
```
【디버그 의뢰】
문제: [구체적인 문제 설명]
에러 메시지: [실제 에러]
재현 절차:
1. [절차1]
2. [절차2]
3. [절차3]

관련 코드: [문제가 있는 코드]
기대하는 동작: [본래의 동작]
```

## 리뷰와 품질 관리

### 인력 리뷰의 포인트

#### 1. 사양과의 정합성 확인
- **설계 의도 반영**: 계획한 기능이 올바르게 구현되었는가
- **요구사항 망라**: 모든 요구사항이 만족되었는가
- **제약 준수**: 설정한 제약이 지켜졌는가

#### 2. 리뷰 대상의 우선순위
1. **사양서**: 요구사항과의 정합성이 최중요
2. **테스트 케이스**: 사양의 적절한 커버리지
3. **구현 코드**: 코드 품질과 사양 적합성

#### 3. 리뷰 체크리스트
- [ ] 기능 요구사항이 만족되었는가
- [ ] 에러 핸들링이 적절한가
- [ ] 보안 요구사항이 고려되었는가
- [ ] 성능 요구사항이 만족되었는가
- [ ] 테스트 커버리지가 충분한가
- [ ] 코드의 가독성·유지보수성이 좋은가

### AI가 기대한 결과를 내지 못하는 경우의 대처법

#### 폴백 전략

**기본 대응 플로우:**
1. **git reset**: 이전 상태로 되돌리기
2. **프롬프트 조정**: 지시를 명확화·상세화
3. **재실행**: 같은 도구 (Claude Sonnet 4)로 재시도
4. **평가**: 결과의 개선도 확인

**git reset의 타이밍:**
- 최종 코드가 기대에서 크게 벗어난 경우
- 수정 의뢰보다 다시 만드는 것이 빠르다고 판단한 경우
- 여러 번의 수정 시도에서 개선이 보이지 않는 경우

#### 프롬프트 조정 기법

**구체성 향상:**
```
# 개선 전
"이 코드를 수정해줘"

# 개선 후
"이 코드의 다음 문제를 수정해주세요:
1. 검증 에러가 적절히 처리되지 않음
2. 반환값의 타입이 사양과 다름
3. 엣지 케이스 테스트가 부족함"
```

**문맥 추가:**
```
# 개선 전
"API를 만들어줘"

# 개선 후
"Express.js를 사용하여 RESTful API 작성:
- 엔드포인트: POST /api/users
- 요청 형식: JSON
- 응답 형식: JSON
- 기존 User 모델 사용
- MongoDB Atlas 연결 완료"
```

## 지속적 개선을 위한 기록

### 성공 패턴의 기록
```markdown
## 성공 사례 기록

### 날짜: 2025-06-21
### 작업: 사용자 인증 API 구현
### 사용한 프롬프트:
[구체적인 프롬프트 내용]

### 결과:
- 한 번에 기대한 대로 구현 완료
- 테스트도 100% 통과

### 배운 점:
- 인증 시스템은 구체적인 라이브러리 지정이 효과적
- 보안 요구사항을 사전에 명시하는 것이 중요
```

### 실패 패턴 분석
```markdown
## 개선 사례 기록

### 날짜: 2025-06-21
### 작업: 복잡한 쿼리 최적화
### 문제:
- 최초 구현이 성능 요구사항을 만족하지 못함
- 3번의 수정 시도에서도 개선되지 않음

### 해결책:
- git reset으로 초기 상태로 되돌리기
- 프롬프트에 성능 요구사항을 수치로 명시
- 참고 구현 예제 제공

### 배운 점:
- 성능 요구사항은 정량적으로 지정하기
- 복잡한 작업은 작게 분할하기
```

## Claude Sonnet 4 이외 도구와의 사용 구분

### Gemini (조사용)와의 상세한 연계

#### Gemini의 사용 장면과 강점
**사용 장면:**
- 새로운 라이브러리 조사
- 기술 문서의 대량 읽기
- 긴 컨텍스트를 요구하는 조사 작업
- 복수 정보원에서의 정보 통합

**Gemini의 고유 강점:**
- **긴 컨텍스트**: 대량 정보를 한 번에 처리 가능
- **정보 수집 능력**: 복수 소스에서의 정보를 효과적으로 통합
- **조사 특화**: 기술 정보 깊이 파기에 우수한 성능

#### 실용적인 연계 워크플로우

**기본적인 연계 패턴:**
```
1. 조사 과제 특정 → Gemini에 의한 정보 수집
2. 정보 정리·요약 → Gemini에 의한 분석
3. 구현 계획 입안 → Claude Sonnet 4에 정보 제공
4. AITDD 실행 → Claude Sonnet 4에 의한 일관된 구현
```

**연계의 구체적 예:**

**예1: 새로운 프레임워크 도입**
```
Gemini:
"Next.js 14의 새로운 기능에 대해 조사하여, 기존 Express.js
애플리케이션에서의 이전 방법을 정리해주세요"

↓ 조사 결과를 Claude Sonnet 4에 제공

Claude Sonnet 4:
"Gemini의 조사 결과를 기반으로, 단계적 이전 계획의 TODO 리스트를
작성하고, AITDD로 첫 번째 기능을 구현해주세요"
```

**예2: 기술 사양의 깊이 조사**
```
Gemini:
"OAuth 2.0과 JWT 인증의 조합에 대해, 보안
베스트 프랙티스와 구현 패턴을 조사해주세요"

↓ 보안 요건을 정리하여 Claude Sonnet 4에 제공

Claude Sonnet 4:
"조사 결과에 기반하여, 보안한 인증 시스템의 테스트 케이스부터
작성하고, AITDD 기법으로 구현해주세요"
```

#### 사용 구분의 판단 기준

**Gemini를 사용해야 하는 경우:**
- [ ] 신기술·신라이브러리의 초회 조사
- [ ] 복수 선택지의 비교 검토가 필요
- [ ] 긴 기술 문서의 읽기가 필요
- [ ] 복잡한 요건의 정리가 필요
- [ ] 선행 사례의 조사가 필요

**Claude Sonnet 4를 사용해야 하는 경우:**
- [ ] 구체적인 구현 작업
- [ ] 테스트 케이스 작성
- [ ] 코드 리뷰와 품질 체크
- [ ] 디버깅과 트러블슈팅
- [ ] 리팩토링 작업

### 실용적인 운용 노하우

#### 프롬프트 설계의 발전적 기법

**컨텍스트 계속의 기술:**
```
# 세션 시작 시
"다음 프로젝트 구성을 기억해주세요:
- Express.js + MongoDB + Jest
- 사용자 인증 기능 구현 완료
- 이번 목표: 사용자 프로필 관리 기능 추가"

# 계속 세션에서의 참조
"앞서 전달한 프로젝트 구성을 전제로,
프로필 업데이트 API의 테스트 케이스를 작성해주세요"
```

**단계적 상세화의 기술:**
```
# 단계1: 개요 레벨
"사용자 관리 시스템의 전체 설계를 생각해주세요"

# 단계2: 기능 레벨
"앞의 설계에서, 프로필 업데이트 기능의 상세 사양을 작성해주세요"

# 단계3: 구현 레벨
"사양을 기반으로, 테스트 케이스와 API 엔드포인트를 구현해주세요"
```

#### 에러 대응의 발전적 전략

**프롬프트 조정의 패턴 분석:**

**패턴1: 구체성 부족에 의한 실패**
```
# 실패 예
"API를 만들어줘"
→ 기대와 크게 다른 구현

# 성공 예
"Express.js로 POST /api/users/profile API 작성:
- 요청: {name, email, bio}
- 검증: email 형식, name 필수
- 응답: 업데이트된 사용자 정보
- 에러 핸들링: 400, 401, 500 대응"
```

**패턴2: 기술 제약의 미지정에 의한 실패**
```
# 실패 예
"데이터베이스 조작 코드를 작성해줘"
→ 사용하지 않는 ORM으로 구현

# 성공 예
"Mongoose 7.x를 사용하여 User 스키마의 업데이트 조작을 구현:
- 기존 User 모델 사용
- findByIdAndUpdate 메서드 사용
- 검증 에러의 적절한 처리"
```

**프롬프트 조정의 실용적 체크리스트:**
- [ ] 사용 기술 스택의 명시
- [ ] 입출력 형식의 구체적 지정
- [ ] 에러 케이스의 고려 지시
- [ ] 기존 코드와의 정합성 확보
- [ ] 성능 요구사항의 명시
- [ ] 보안 고려사항의 지시

#### 지속적 개선을 위한 기록 방법

**성공 패턴의 템플릿화:**
```markdown
## 프롬프트 템플릿: API 구현

### 기본 형식
"[프레임워크명]으로 [HTTP메서드] [엔드포인트] API를 구현:
- 요청 형식: [상세]
- 응답 형식: [상세]
- 검증: [요건]
- 에러 핸들링: [대응하는 상태 코드]
- 기존 [모델명] 모델 사용"

### 적용 예
[구체적인 사용 예]

### 기대되는 결과
[성공 시의 출력 패턴]
```

**실패 패턴의 분석 기록:**
```markdown
## 개선 기록: [날짜]

### 문제가 있던 프롬프트
[원래 프롬프트]

### 발생한 문제
- [구체적인 문제1]
- [구체적인 문제2]

### 개선 후의 프롬프트
[수정판 프롬프트]

### 개선 포인트
- [개선점1]
- [개선점2]

### 향후 적용 지침
[다른 케이스로의 응용 방법]
```

### 다른 AI 도구와의 비교 상세

**왜 Claude Sonnet 4에 집약하는가:**

**1. 일관성의 중요성**
- 같은 도구에 의한 통일된 접근
- 학습한 최적화가 누적적으로 효과 발휘
- 도구 고유의 버릇이나 제한에 대한 대응이 축적

**2. 학습 효율의 최대화**
- 하나의 도구에 숙련함으로써 효율 향상
- 프롬프트 설계의 노하우가 심화
- 에러 패턴과 대처법의 축적

**3. 비용 관리의 간소화**
- 복수 도구보다 단일 도구가 관리하기 쉬움
- 예산 계획의 간소화
- 사용량 감시의 일원화

**4. 폴백 전략의 간결성**
- 복잡한 판단 로직을 피할 수 있음
- "어떤 도구로 재시도할지"의 판단이 불필요
- 신속한 문제 해결이 가능

**도구 통합에 의한 메리트:**
```
항목                     통합 접근      복수 도구 접근
─────────────────────────────────────────────────────
학습 비용                낮음          높음
프롬프트 최적화 효율     높음          낮음
비용 관리 복잡도         낮음          높음
폴백 판단                간단          복잡
지식 축적 효율           높음          분산
─────────────────────────────────────────────────────
총합적 개발 효율         최적화        비효율
```

### AI 도구 환경의 미래 대응

#### 신기술에 대한 대응 방침
**평가 기준의 체계화:**
- **성능 평가**: 기존 워크플로우에서의 성능 비교
- **비용 분석**: 총소유비용 (학습 비용 포함) 평가
- **통합성 평가**: 현재 개발 환경과의 친화성
- **이전 비용**: 도구 변경에 따른 비용 견적

**단계적 도입 접근:**
1. **정보 수집기**: 3-6개월 관찰 기간
2. **소규모 테스트**: 비중요 프로젝트에서의 시용
3. **비교 평가**: 정량적 성능·효율 비교
4. **단계적 이전**: 명확한 우위성 확인 후의 신중한 이전

**판단의 정량화:**
```
신도구 채용의 임계값:
- 성능 향상: 20% 이상
- 비용 삭감: 15% 이상
- 학습 비용: 2주 이내
- 통합 비용: 현재 도구의 50% 이하
```

## 다음 단계

Claude Sonnet 4의 활용 방법을 이해했다면, 다음 장 "2.3 개발 환경과 워크플로우 구축"에서 AITDD를 실천하기 위한 종합적인 개발 환경을 구축해봅시다. TODO 관리부터 Git 워크플로우까지, 체계적인 개발 프로세스를 확립합니다.