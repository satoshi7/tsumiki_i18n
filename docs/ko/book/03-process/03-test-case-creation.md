# 3.3 테스트 케이스 작성

## 테스트 케이스 작성의 중요성

AITDD에서 테스트 케이스는 구현 품질을 결정하는 중요한 요소입니다. AI가 생성하는 코드의 품질은 테스트 케이스의 망라성과 정확도에 크게 의존하므로, 이 단계에서 포괄적인 테스트 케이스를 설계하는 것이 중요합니다.

## 테스트 케이스 설계 원칙

### 1. 망라성 확보

#### 기능의 망라성
- **정상계**: 기대되는 모든 동작
- **이상계**: 오류 처리와 검증
- **경계값**: 입력값의 경계 조건
- **엣지 케이스**: 특수한 조건이나 예외적인 상황

#### 테스트 레벨의 망라성
- **단위 테스트**: 개별 함수·메서드 테스트
- **통합 테스트**: 컴포넌트 간 연계 테스트
- **엔드투엔드 테스트**: 사용자 시나리오의 완전 실행

### 2. 명확하고 구체적인 기대값

```markdown
❌ 나쁜 예: "오류가 발생할 것"
✅ 좋은 예: "상태 코드 400과 오류 메시지 'Email already exists'가 반환될 것"
```

### 3. 독립성과 재현성
- 각 테스트 케이스는 독립적으로 실행 가능
- 테스트 실행 순서에 의존하지 않음
- 외부 환경에 의존하지 않음

## 테스트 케이스 문서의 표준 포맷

### 기본 템플릿

```markdown
# [기능명] 테스트 케이스 사양서

## 테스트 개요
- **대상 기능**: 테스트 대상 기능명
- **테스트 목적**: 무엇을 검증할지
- **전제 조건**: 테스트 실행의 전제

## 테스트 케이스 목록

### TC001: [테스트 케이스명]
- **분류**: 정상계/이상계/경계값
- **목적**: 이 테스트로 검증할 내용
- **전제 조건**: 테스트 실행 전 상태
- **테스트 데이터**: 입력 데이터의 상세
- **실행 절차**: 
  1. 구체적인 절차1
  2. 구체적인 절차2
- **기대 결과**: 
  - 기대되는 동작의 상세
  - 기대되는 출력값
- **사후 조건**: 테스트 실행 후 기대되는 상태
```

### 구체적인 테스트 케이스 예시

#### 예: 사용자 등록 기능 테스트 케이스

```markdown
# 사용자 등록 기능 테스트 케이스 사양서

## 테스트 개요
- **대상 기능**: 사용자 신규 등록 API (POST /api/users)
- **테스트 목적**: 신규 사용자 등록의 모든 패턴 검증
- **전제 조건**: 데이터베이스가 초기 상태, API 서버가 가동 중

## 테스트 케이스 목록

### TC001: 정상적인 사용자 등록
- **분류**: 정상계
- **목적**: 유효한 데이터로 신규 사용자 등록 검증
- **전제 조건**: test@example.com은 미등록
- **테스트 데이터**: 
  ```json
  {
    "email": "test@example.com",
    "password": "SecurePass123!",
    "password_confirmation": "SecurePass123!"
  }
  ```
- **실행 절차**: 
  1. POST /api/users에 테스트 데이터 전송
  2. 응답 확인
  3. 데이터베이스 상태 확인
- **기대 결과**: 
  - 상태 코드: 201
  - 응답: 
    ```json
    {
      "id": 임의의 양의 정수,
      "email": "test@example.com",
      "created_at": "날짜시간(ISO8601 형식)"
    }
    ```
  - 데이터베이스: users 테이블에 새로운 레코드가 생성됨
  - 패스워드가 해시화되어 저장됨
- **사후 조건**: 사용자가 정상적으로 등록되어 로그인 가능

### TC002: 이메일 주소 중복 오류
- **분류**: 이상계
- **목적**: 기존 이메일 주소로 등록 시 오류 처리 검증
- **전제 조건**: test@example.com이 이미 등록됨
- **테스트 데이터**: 
  ```json
  {
    "email": "test@example.com",
    "password": "AnotherPass456!",
    "password_confirmation": "AnotherPass456!"
  }
  ```
- **실행 절차**: 
  1. POST /api/users에 테스트 데이터 전송
  2. 응답 확인
  3. 데이터베이스 상태 확인
- **기대 결과**: 
  - 상태 코드: 400
  - 응답: 
    ```json
    {
      "error": "validation_failed",
      "details": [
        {
          "field": "email",
          "message": "Email already exists"
        }
      ]
    }
    ```
  - 데이터베이스: 새로운 레코드는 생성되지 않음
- **사후 조건**: 기존 사용자 데이터에 영향 없음

### TC003: 패스워드 불일치 오류
- **분류**: 이상계
- **목적**: 패스워드와 확인 패스워드 불일치 시 오류 처리 검증
- **전제 조건**: 신규 이메일 주소 사용
- **테스트 데이터**: 
  ```json
  {
    "email": "new@example.com",
    "password": "SecurePass123!",
    "password_confirmation": "DifferentPass456!"
  }
  ```
- **기대 결과**: 
  - 상태 코드: 400
  - 오류 메시지: "Password confirmation does not match"

### TC004: 무효한 이메일 주소 형식
- **분류**: 이상계·경계값
- **목적**: 이메일 주소 형식 검증 확인
- **테스트 데이터 집합**:
  - "invalid-email" (@가 없음)
  - "test@" (도메인 부분이 없음)
  - "@example.com" (로컬 부분이 없음)
  - "test..test@example.com" (연속 점)
- **기대 결과**: 모두 400 오류가 될 것

### TC005: 패스워드 강도 부족
- **분류**: 이상계·경계값
- **목적**: 패스워드 강도 검증 확인
- **테스트 데이터 집합**:
  - "short" (8자 미만)
  - "onlylowercase" (소문자만)
  - "ONLYUPPERCASE" (대문자만)
  - "12345678" (숫자만)
  - "NoSymbol123" (기호 없음)
- **기대 결과**: 모두 400 오류가 될 것

### TC006: 필수 항목 미입력
- **분류**: 이상계
- **목적**: 필수 항목의 검증 확인
- **테스트 데이터 집합**:
  - email 없음
  - password 없음
  - password_confirmation 없음
  - 빈 문자열 케이스
  - null 케이스
- **기대 결과**: 모두 400 오류가 될 것

### TC007: 경계값 테스트 - 이메일 주소 길이
- **분류**: 경계값
- **목적**: 이메일 주소의 문자 수 제한 검증
- **테스트 데이터**:
  - 254자 (최대 허용)
  - 255자 (제한 초과)
- **기대 결과**: 
  - 254자: 정상 등록
  - 255자: 400 오류

### TC008: 속도 제한 테스트
- **분류**: 비기능
- **목적**: 동시 등록의 속도 제한 검증
- **실행 절차**: 짧은 시간에 대량의 요청 전송
- **기대 결과**: 제한을 초과한 경우 429 오류

### TC009: 데이터베이스 연결 오류
- **분류**: 이상계·인프라
- **목적**: 데이터베이스 장애 시 동작 검증
- **전제 조건**: 데이터베이스를 사용할 수 없음
- **기대 결과**: 500 오류와 오류 로그 출력

### TC010: CSRF 토큰 검증
- **분류**: 보안
- **목적**: CSRF 공격 방지 검증
- **테스트 데이터**: CSRF 토큰 없음, 또는 무효한 토큰
- **기대 결과**: 403 오류
```

## 테스트 케이스 작성 워크플로우

### 1. 사양서에서 테스트 케이스 추출

```markdown
사양서의 각 항목 → 대응하는 테스트 케이스

■ 기능 요구사항
- 기본 기능 → 정상계 테스트 케이스
- 검증 → 이상계 테스트 케이스
- 입력 제한 → 경계값 테스트 케이스

■ 비기능 요구사항
- 성능 → 부하 테스트 케이스
- 보안 → 보안 테스트 케이스
- 가용성 → 장애 테스트 케이스
```

### 2. 테스트 케이스 설계 절차

#### 단계1: 테스트 관점 정리
```markdown
## 테스트 관점 목록

### 기능 관점
- [ ] 정상 입력에서의 동작
- [ ] 입력값 검증
- [ ] 오류 처리
- [ ] 데이터 영속화

### 데이터 관점
- [ ] 경계값 (최소, 최대)
- [ ] 특수 문자·다국어
- [ ] NULL·빈 문자열
- [ ] 부정한 형식

### 상태 관점
- [ ] 초기 상태
- [ ] 데이터 존재 상태
- [ ] 오류 상태
- [ ] 제한 상태

### 환경 관점
- [ ] 정상 환경
- [ ] 고부하 환경
- [ ] 장애 환경
```

#### 단계2: 테스트 케이스 매트릭스 작성

| 기능 | 정상계 | 이상계 | 경계값 | 보안 | 성능 |
|------|--------|--------|--------|------|------|
| 사용자 등록 | TC001 | TC002-006 | TC007 | TC010 | TC008 |
| 검증 | - | TC002-006 | TC004,005,007 | - | - |
| 데이터 저장 | TC001 | TC009 | - | - | - |

#### 단계3: 상세 테스트 케이스 작성
- 각 셀의 내용을 상세한 테스트 케이스로 전개
- 실행 가능한 구체적 절차로 세분화
- 기대 결과를 명확히 정의

### 3. AI 활용에 의한 테스트 케이스 지원

#### AI를 활용할 수 있는 영역
- **망라성 체크**: 누락된 테스트 케이스 지적
- **테스트 데이터 생성**: 경계값이나 이상값 제안
- **기대값 계산**: 복잡한 계산 결과 산출
- **테스트 케이스 구조화**: 포맷 통일

#### 인간이 판단해야 할 영역
- **비즈니스 요구사항 이해**: 도메인 고유 요구사항
- **위험도 평가**: 영향도와 중요도 판정
- **테스트 우선순위**: 실행 순서와 자원 배분
- **품질 기준**: 수락 기준 설정

## 테스트 케이스 품질 체크포인트

### 1. 완전성 확인

#### 기능 커버리지
```markdown
## 커버리지 체크리스트

### API 사양서의 각 항목
- [ ] 모든 엔드포인트에 테스트 케이스 있음
- [ ] 모든 매개변수에 테스트 케이스 있음
- [ ] 모든 응답 패턴에 테스트 케이스 있음

### 오류 처리
- [ ] 모든 오류 코드에 테스트 케이스 있음
- [ ] 모든 검증 규칙에 테스트 케이스 있음
- [ ] 모든 예외 패턴에 테스트 케이스 있음
```

#### 비즈니스 규칙 커버리지
```markdown
### 비즈니스 규칙 검증
- [ ] 모든 업무 플로우에 테스트 케이스 있음
- [ ] 모든 업무 예외에 테스트 케이스 있음
- [ ] 모든 권한 패턴에 테스트 케이스 있음
```

### 2. 실행 가능성 확인

#### 테스트 데이터 준비 가능성
- 필요한 테스트 데이터를 준비할 수 있는가
- 외부 의존 서비스의 모킹이 가능한가
- 테스트 환경에서의 실행이 가능한가

#### 기대 결과의 검증 가능성
- 기대 결과를 객관적으로 판정할 수 있는가
- 검증에 필요한 도구나 방법을 사용할 수 있는가
- 자동화가 어려운 부분의 수동 확인 방법

### 3. 유지보수성 확인

#### 테스트 케이스의 독립성
- 각 테스트 케이스가 독립적으로 실행 가능
- 테스트 순서에 의존하지 않음
- 병렬 실행이 가능

#### 변경에 대한 대응
- 사양 변경 시 영향 범위가 명확
- 테스트 케이스 수정이 용이
- 테스트 데이터 관리가 간단

## 인간 검토 포인트

### 검토 관점

#### 1. 비즈니스 요구사항과의 정합성
- [ ] 사용자 스토리가 적절하게 테스트되는가
- [ ] 비즈니스 규칙이 올바르게 반영되는가
- [ ] 엣지 케이스가 업무 관점에서 타당한가

#### 2. 위험 기반 우선순위
- [ ] 고위험 기능에 충분한 테스트 케이스가 있는가
- [ ] 중요한 업무 플로우가 망라되는가
- [ ] 보안 요구사항이 적절하게 테스트되는가

#### 3. 테스트 효율성
- [ ] 테스트 케이스 수가 적절한가 (과다/과소가 아님)
- [ ] 중복되는 테스트 케이스가 없는가
- [ ] 자동화 가능한 부분과 수동 테스트의 분리가 적절한가

### 검토 프로세스

#### 단계1: 초기 검토
- 사양서와의 정합성 확인
- 망라성 기본 체크
- 명백한 누락이나 문제 지적

#### 단계2: 상세 검토
- 각 테스트 케이스의 타당성 확인
- 기대 결과의 정확성 확인
- 실행 가능성 검증

#### 단계3: 최종 승인
- 전체적인 품질 확인
- 테스트 실행 계획 확인
- 다음 단계로의 진행 판정

## 테스트 케이스 작성 모범 사례

### 1. 단계적 상세화

```markdown
제1단계: 개요 레벨
"사용자 등록의 정상계·이상계를 테스트한다"

제2단계: 기능 레벨
"유효한 데이터로 등록 성공"
"무효한 데이터로 등록 실패"

제3단계: 상세 레벨
"TC001: 정상적인 사용자 등록"
"TC002: 이메일 주소 중복 오류"
```

### 2. 테스트 데이터의 전략적 설계

#### 데이터 패턴의 체계화
```markdown
## 기본 데이터 세트
- 정상 데이터: 일반적인 유효값
- 경계 데이터: 제한값 (최소/최대)
- 이상 데이터: 무효값·부정값
- 특수 데이터: 특수 문자·다국어·NULL
```

#### 재사용 가능한 테스트 데이터
- 공통적으로 사용하는 테스트 데이터 정의
- 테스트 데이터 변형 관리
- 데이터 생성 자동화

### 3. 기대 결과의 정밀한 정의

#### 구체적인 기대값
```markdown
❌ "오류가 될 것"
✅ "HTTP 400 + {"error": "validation_failed", "field": "email"}"

❌ "정상적으로 등록될 것"
✅ "HTTP 201 + 사용자 ID 반환 + DB에 레코드 생성"
```

#### 검증 가능한 조건
- 출력값의 구체적인 값이나 형식
- 데이터베이스 상태 변화
- 로그 출력 내용
- 외부 시스템에 대한 영향

## 자주 발생하는 문제와 대책

### 문제1: 테스트 케이스의 입도가 부적절

**증상**: 
- 하나의 테스트 케이스로 여러 기능을 테스트
- 반대로 너무 세분화되어 관리 비용이 높음

**대책**: 
- 하나의 테스트 케이스 = 하나의 검증 관점
- 비즈니스 가치가 있는 단위로 그룹화

### 문제2: 기대 결과가 애매

**증상**: 
- "정상적으로 동작한다", "오류가 발생한다" 등
- 판정 기준이 불명확

**대책**: 
- 구체적인 값이나 상태를 명기
- 자동 테스트에서의 판정 조건을 의식

### 문제3: 테스트 케이스 누락

**증상**: 
- 엣지 케이스가 미고려
- 오류 패턴 부족

**대책**: 
- 체크리스트에 의한 체계적 확인
- 동치 클래스 분할이나 경계값 분석 활용

### 문제4: 유지보수성 부족

**증상**: 
- 사양 변경 시 테스트 케이스 수정이 어려움
- 테스트 데이터 관리가 번잡

**대책**: 
- 모듈화된 설계
- 재사용 가능한 테스트 데이터 설계

## 다음 단계로의 준비

테스트 케이스 작성이 완료되면, 다음은 [Red-Green-Refactor-Validation 사이클](./04-rgr-validation-cycle.md)로 진행합니다.

### 성과물 확인
- [ ] testcases.md가 상세하게 작성되어 있다
- [ ] 모든 사양 항목에 테스트 케이스가 대응되어 있다
- [ ] 기대 결과가 구체적으로 정의되어 있다
- [ ] 인간에 의한 검토가 완료되었다
- [ ] 테스트 데이터를 준비할 수 있다

### 품질 체크리스트
- [ ] **망라성**: 정상계·이상계·경계값이 커버되어 있다
- [ ] **명확성**: 기대 결과가 구체적이고 검증 가능하다
- [ ] **독립성**: 각 테스트 케이스가 독립적으로 실행 가능하다
- [ ] **실현성**: 테스트 환경에서 실행 가능하다
- [ ] **유지보수성**: 사양 변경에 대응하기 쉬운 구조다

적절한 테스트 케이스 작성으로 AI가 고품질 코드를 생성할 기반이 마련됩니다. 다음 장에서는 이러한 테스트 케이스를 바탕으로 한 구현 사이클을 자세히 해설합니다.