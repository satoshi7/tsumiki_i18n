# 2.2 Claude Sonnet 4的活用方法

本节解释AITDD核心工具Claude Sonnet 4的有效活用方法。不是简单地让AI编写代码，而是学习人类与AI协作开发高质量软件的方法。

## Claude Sonnet 4的特征和优势

### 在AITDD中的定位
- **Red-Green-Refactor-Validation循环的执行主体**
- **从设计到测试、实现的一致负责**
- **高质量代码生成与质量检查并重**

### 选择理由
- **可访问性**：通过Claude Code可自由使用
- **编码性能**：必要充分水平的稳定性能
- **成本效率**：合理的成本水平（$20/月）
- **AITDD适用性**：最适合重视试验的开发风格
- **集成性**：与VS Code环境的优秀协作

## Claude Code的基本使用方法

### 启动和基本操作

1. **启动Claude Code**
   ```bash
   # 在VS Code内启动Claude Code
   # 或通过浏览器版Claude访问
   ```

2. **与项目的协作**
   - 指定项目目录
   - 识别文件结构
   - 理解既有代码

### AITDD中的基本对话模式

#### 1. 目标设定阶段
```
您："我想实现用户管理功能的CRUD操作。请先创建TODO列表。"

Claude："我将创建用户管理功能的TODO列表：
1. 定义用户模型
2. 创建用户创建的测试用例
3. 实现用户创建功能
..."
```

#### 2. 测试创建阶段
```
您："请创建TODO第一项的测试用例。"

Claude："我将创建用户模型的测试用例：
```javascript
describe('User Model', () => {
  test('should create user with valid data', () => {
    // 测试代码
  });
});
```"
```

#### 3. 实现阶段
```
您："请实现让这个测试通过的代码。"

Claude："我将实现让测试通过的用户模型：
```javascript
class User {
  constructor(name, email) {
    // 实现代码
  }
}
```"
```

## 有效的提示设计

### 提示设计的基本原则

#### 1. 明确的目标设定
**好的例子：**
```
"我想实现用户注册API（POST /users）。
- 带验证功能
- 包含错误处理
- 想以测试优先的方式进行"
```

**不好的例子：**
```
"创建用户功能"
```

#### 2. 提供上下文
```
"当前项目配置：
- Express.js + MongoDB
- Jest for testing
- 已有User模型

要新增的功能：
- 用户档案更新API"
```

#### 3. 明示约束条件
```
"约束条件：
- 保持与既有API的兼容性
- 考虑安全性的实现
- 性能要求：1秒内响应"
```

### 提示优化的迭代过程

#### 步骤1：初次执行
1. **创建提示**
2. **请求AI执行**
3. **评估结果**

#### 步骤2：评估和改进
1. **识别与期望的差异**
2. **分析提示的问题点**
3. **设计改进版提示**

#### 步骤3：重新执行
1. **用改进的提示执行**
2. **确认结果的改进程度**
3. **必要时进一步调整**

### 实用的提示模板

#### 功能实现用模板
```
【实现请求】
功能：[具体功能名称]
技术栈：[使用技术的列举]
要求：
- [要求1]
- [要求2]
- [要求3]

约束：
- [约束1]
- [约束2]

期待的成果物：
- 测试用例
- 实现代码
- 文档（必要时）
```

#### 调试用模板
```
【调试请求】
问题：[具体问题说明]
错误消息：[实际错误]
重现步骤：
1. [步骤1]
2. [步骤2]
3. [步骤3]

相关代码：[有问题的代码]
期待行为：[本应的行为]
```

## 审查和质量管理

### 人工审查的要点

#### 1. 规格整合性确认
- **设计意图的反映**：计划的功能是否正确实现
- **要求的覆盖**：是否满足所有要求
- **约束的遵守**：是否遵守设定的约束

#### 2. 审查对象的优先级
1. **规格书**：与要求的整合性最重要
2. **测试用例**：规格的适当覆盖
3. **实现代码**：代码质量和规格适合性

#### 3. 审查检查清单
- [ ] 功能要求是否得到满足
- [ ] 错误处理是否适当
- [ ] 安全要求是否被考虑
- [ ] 性能要求是否得到满足
- [ ] 测试覆盖率是否充分
- [ ] 代码的可读性·可维护性是否良好

### AI未产生期待结果时的处理方法

#### 回退策略

**基本对应流程：**
1. **git reset**：回到之前状态
2. **提示调整**：明确化·详细化指示
3. **重新执行**：用同一工具（Claude Sonnet 4）重试
4. **评估**：确认结果的改进程度

**git reset的时机：**
- 最终代码与期待大幅偏离时
- 判断重新制作比修正请求更快时
- 多次修正尝试未见改善时

#### 提示调整技巧

**提高具体性：**
```
# 改进前
"修正这个代码"

# 改进后
"修正这个代码的以下问题：
1. 验证错误未得到适当处理
2. 返回值类型与规格不同
3. 边界情况测试不足"
```

**添加上下文：**
```
# 改进前
"创建API"

# 改进后
"使用Express.js创建RESTful API：
- 端点：POST /api/users
- 请求格式：JSON
- 响应格式：JSON
- 使用既有User模型
- MongoDB Atlas已连接"
```

## 持续改进的记录

### 成功模式的记录
```markdown
## 成功案例记录

### 日期：2025-06-21
### 任务：用户认证API实现
### 使用的提示：
[具体提示内容]

### 结果：
- 一次就完成期待的实现
- 测试也100%通过

### 学习：
- 认证系统具体指定库是有效的
- 事先明示安全要求很重要
```

### 失败模式分析
```markdown
## 改进案例记录

### 日期：2025-06-21
### 任务：复杂查询优化
### 问题：
- 最初实现未满足性能要求
- 3次修正尝试也未改善

### 解决方案：
- 用git reset回到初始状态
- 在提示中用数值明示性能要求
- 提供参考实现例子

### 学习：
- 性能要求要定量指定
- 复杂任务要小分割
```

## Claude Sonnet 4以外工具的使用分工

### 与Gemini（调查用）的详细协作

#### Gemini的使用场景和优势
**使用场景：**
- 新库的调查
- 技术文档的大量读取
- 需要长上下文的调查任务
- 多个信息源的信息整合

**Gemini的固有优势：**
- **长上下文**：可一次处理大量信息
- **信息收集能力**：有效整合多个来源的信息
- **调查特化**：在技术信息深入挖掘方面性能优秀

#### 实用的协作工作流

**基本协作模式：**
```
1. 识别调查课题 → Gemini进行信息收集
2. 信息整理·总结 → Gemini进行分析
3. 实现计划立案 → 向Claude Sonnet 4提供信息
4. AITDD执行 → Claude Sonnet 4进行一致实现
```

**协作的具体例子：**

**例1：导入新框架**
```
Gemini：
"请调查Next.js 14的新功能，整理从既有Express.js
应用的迁移方法"

↓ 向Claude Sonnet 4提供调查结果

Claude Sonnet 4：
"基于Gemini的调查结果，创建分阶段迁移计划的TODO列表，
用AITDD实现第一个功能"
```

**例2：技术规格深入调查**
```
Gemini：
"请调查OAuth 2.0和JWT认证组合的安全最佳实践
和实现模式"

↓ 整理安全要求向Claude Sonnet 4提供

Claude Sonnet 4：
"基于调查结果，先创建安全认证系统的测试用例，
用AITDD手法实现"
```

#### 使用分工的判断基准

**应该使用Gemini的场合：**
- [ ] 新技术·新库的初次调查
- [ ] 需要比较多个选择的检讨
- [ ] 需要读取长技术文档
- [ ] 需要整理复杂要求
- [ ] 需要调查先行事例

**应该使用Claude Sonnet 4的场合：**
- [ ] 具体实现作业
- [ ] 测试用例的创建
- [ ] 代码审查和质量检查
- [ ] 调试和故障排除
- [ ] 重构作业

### 实用的运用诀窍

#### 提示设计的发展技巧

**上下文继续的技术：**
```
# 会话开始时
"请记住以下项目配置：
- Express.js + MongoDB + Jest
- 用户认证功能已实现
- 本次目标：追加用户档案管理功能"

# 继续会话中的参照
"以刚才传达的项目配置为前提，
请创建档案更新API的测试用例"
```

**阶段性详细化的技术：**
```
# 阶段1：概要级别
"请考虑用户管理系统的整体设计"

# 阶段2：功能级别
"从刚才的设计，请创建档案更新功能的详细规格"

# 阶段3：实现级别
"基于规格，请实现测试用例和API端点"
```

#### 错误对应的发展策略

**提示调整的模式分析：**

**模式1：因具体性不足导致的失败**
```
# 失败例
"创建API"
→ 与期待大不相同的实现

# 成功例
"用Express.js创建POST /api/users/profile API：
- 请求：{name, email, bio}
- 验证：email格式、name必须
- 响应：更新的用户信息
- 错误处理：对应400, 401, 500"
```

**模式2：因技术约束未指定导致的失败**
```
# 失败例
"写数据库操作的代码"
→ 用未使用的ORM实现

# 成功例
"使用Mongoose 7.x实现User模式的更新操作：
- 使用既有User模型
- 使用findByIdAndUpdate方法
- 适当处理验证错误"
```

**提示调整的实用检查清单：**
- [ ] 明示使用技术栈
- [ ] 具体指定输入输出格式
- [ ] 考虑错误情况的指示
- [ ] 确保与既有代码的整合性
- [ ] 明示性能要求
- [ ] 安全考虑事项的指示

#### 持续改进的记录方法

**成功模式的模板化：**
```markdown
## 提示模板：API实现

### 基本形式
"用[框架名]实现[HTTP方法] [端点] API：
- 请求格式：[详细]
- 响应格式：[详细]
- 验证：[要求]
- 错误处理：[对应的状态码]
- 使用既有[模型名]模型"

### 适用例
[具体使用例]

### 期待的结果
[成功时的输出模式]
```

**失败模式的分析记录：**
```markdown
## 改进记录：[日期]

### 有问题的提示
[原提示]

### 发生的问题
- [具体问题1]
- [具体问题2]

### 改进后的提示
[修正版提示]

### 改进要点
- [改进点1]
- [改进点2]

### 今后的适用指针
[对其他案例的应用方法]
```

### 与其他AI工具比较的详细

**为什么集约到Claude Sonnet 4：**

**1. 一致性的重要性**
- 同一工具的统一方法
- 学习到的优化发挥累积效果
- 对工具固有癖好和限制的对应得到积累

**2. 学习效率的最大化**
- 通过熟练一个工具提高效率
- 提示设计的诀窍深化
- 错误模式和对处法的积累

**3. 成本管理的简化**
- 单一工具比多个工具更易管理
- 预算计划的简化
- 使用量监控的一元化

**4. 回退策略的简洁性**
- 可避免复杂判断逻辑
- 不需要"用哪个工具重试"的判断
- 可实现迅速问题解决

**工具整合的优点：**
```
项目                     整合方法      多工具方法
─────────────────────────────────────────────────────
学习成本                 低            高
提示优化效率             高            低
成本管理复杂度           低            高
回退判断                 简单          复杂
知识积累效率             高            分散
─────────────────────────────────────────────────────
总合开发效率             最优化        非效率
```

### AI工具环境的未来对应

#### 新技术的对应方针
**评价基准的体系化：**
- **性能评价**：在既有工作流中的性能比较
- **成本分析**：总拥有成本（含学习成本）的评价
- **整合性评价**：与当前开发环境的亲和性
- **迁移成本**：工具变更伴随成本的估算

**阶段性导入方法：**
1. **信息收集期**：3-6个月观察期间
2. **小规模测试**：在非重要项目中试用
3. **比较评价**：定量的性能·效率比较
4. **阶段性迁移**：确认明确优势后的慎重迁移

**判断的定量化：**
```
新工具采用的阈值：
- 性能提升：20%以上
- 成本削减：15%以上
- 学习成本：2周以内
- 整合成本：当前工具的50%以下
```

## 下一步

理解了Claude Sonnet 4的活用方法后，在下一章"2.3 开发环境和工作流构建"中构建实践AITDD的综合开发环境。从TODO管理到Git工作流，建立体系化的开发过程。