# 3.3 测试用例创建

## 测试用例创建的重要性

在AITDD中，测试用例是决定实现质量的重要元素。AI生成代码的质量很大程度上依赖于测试用例的全面性和准确性，因此在这个阶段设计全面的测试用例至关重要。

## 测试用例设计原则

### 1. 确保全面性

#### 功能覆盖性
- **正常情况**：所有预期行为
- **异常情况**：错误处理和验证
- **边界值**：输入值的边界条件
- **边缘情况**：特殊条件或异常情况

#### 测试级别覆盖性
- **单元测试**：测试单个函数和方法
- **集成测试**：测试组件间的交互
- **端到端测试**：用户场景的完整执行

### 2. 明确且具体的期望值

```markdown
❌ 错误示例："应该发生错误"
✅ 正确示例："应该返回状态码400和错误消息'Email already exists'"
```

### 3. 独立性和可重现性
- 每个测试用例可以独立执行
- 不依赖测试执行顺序
- 不依赖外部环境

## 测试用例文档的标准格式

### 基本模板

```markdown
# [功能名称] 测试用例规格书

## 测试概述
- **目标功能**：要测试的功能名称
- **测试目的**：要验证什么
- **前提条件**：测试执行的前提

## 测试用例列表

### TC001：[测试用例名称]
- **分类**：正常/异常/边界
- **目的**：此测试要验证的内容
- **前提条件**：测试执行前的状态
- **测试数据**：输入数据详情
- **执行步骤**：
  1. 具体步骤1
  2. 具体步骤2
- **期望结果**：
  - 期望行为的详细内容
  - 期望的输出值
- **后置条件**：测试执行后的期望状态
```

### 具体的测试用例示例

#### 示例：用户注册功能的测试用例

```markdown
# 用户注册功能 测试用例规格书

## 测试概述
- **目标功能**：用户新注册API (POST /api/users)
- **测试目的**：验证新用户注册的所有模式
- **前提条件**：数据库处于初始状态，API服务器运行中

## 测试用例列表

### TC001：正常用户注册
- **分类**：正常
- **目的**：验证使用有效数据的新用户注册
- **前提条件**：test@example.com 未注册
- **测试数据**：
  ```json
  {
    "email": "test@example.com",
    "password": "SecurePass123!",
    "password_confirmation": "SecurePass123!"
  }
  ```
- **执行步骤**：
  1. 向POST /api/users发送测试数据
  2. 确认响应
  3. 确认数据库状态
- **期望结果**：
  - 状态码：201
  - 响应：
    ```json
    {
      "id": 任意正整数,
      "email": "test@example.com",
      "created_at": "日期时间（ISO8601格式）"
    }
    ```
  - 数据库：在users表中创建新记录
  - 密码被哈希化并保存
- **后置条件**：用户成功注册并可以登录

### TC002：邮箱地址重复错误
- **分类**：异常
- **目的**：验证使用已存在邮箱注册时的错误处理
- **前提条件**：test@example.com 已经注册
- **测试数据**：
  ```json
  {
    "email": "test@example.com",
    "password": "AnotherPass456!",
    "password_confirmation": "AnotherPass456!"
  }
  ```
- **执行步骤**：
  1. 向POST /api/users发送测试数据
  2. 确认响应
  3. 确认数据库状态
- **期望结果**：
  - 状态码：400
  - 响应：
    ```json
    {
      "error": "validation_failed",
      "details": [
        {
          "field": "email",
          "message": "Email already exists"
        }
      ]
    }
    ```
  - 数据库：不创建新记录
- **后置条件**：对现有用户数据无影响

### TC003：密码不匹配错误
- **分类**：异常
- **目的**：验证密码和确认密码不匹配时的错误处理
- **前提条件**：使用新的邮箱地址
- **测试数据**：
  ```json
  {
    "email": "new@example.com",
    "password": "SecurePass123!",
    "password_confirmation": "DifferentPass456!"
  }
  ```
- **期望结果**：
  - 状态码：400
  - 错误消息："Password confirmation does not match"

### TC004：无效的邮箱地址格式
- **分类**：异常/边界
- **目的**：验证邮箱地址格式验证
- **测试数据集**：
  - "invalid-email"（没有@）
  - "test@"（没有域名部分）
  - "@example.com"（没有本地部分）
  - "test..test@example.com"（连续的点）
- **期望结果**：所有情况都应该返回400错误

### TC005：密码强度不足
- **分类**：异常/边界
- **目的**：验证密码强度验证
- **测试数据集**：
  - "short"（少于8个字符）
  - "onlylowercase"（仅小写字母）
  - "ONLYUPPERCASE"（仅大写字母）
  - "12345678"（仅数字）
  - "NoSymbol123"（无符号）
- **期望结果**：所有情况都应该返回400错误

### TC006：必填字段缺失
- **分类**：异常
- **目的**：验证必填字段的验证
- **测试数据集**：
  - 缺少email
  - 缺少password
  - 缺少password_confirmation
  - 空字符串情况
  - null情况
- **期望结果**：所有情况都应该返回400错误

### TC007：边界值测试 - 邮箱地址长度
- **分类**：边界
- **目的**：验证邮箱地址字符数限制
- **测试数据**：
  - 254个字符（最大允许）
  - 255个字符（超出限制）
- **期望结果**：
  - 254个字符：正常注册
  - 255个字符：400错误

### TC008：速率限制测试
- **分类**：非功能
- **目的**：验证并发注册的速率限制
- **执行步骤**：短时间内发送大量请求
- **期望结果**：超出限制时返回429错误

### TC009：数据库连接错误
- **分类**：异常/基础设施
- **目的**：验证数据库故障时的行为
- **前提条件**：数据库不可用
- **期望结果**：500错误和错误日志输出

### TC010：CSRF令牌验证
- **分类**：安全
- **目的**：验证CSRF攻击防护
- **测试数据**：无CSRF令牌或无效令牌
- **期望结果**：403错误
```

## 测试用例创建的工作流程

### 1. 从规格书提取测试用例

```markdown
规格书各项目 → 对应的测试用例

■ 功能需求
- 基本功能 → 正常测试用例
- 验证 → 异常测试用例
- 输入限制 → 边界值测试用例

■ 非功能需求
- 性能 → 负载测试用例
- 安全 → 安全测试用例
- 可用性 → 故障测试用例
```

### 2. 测试用例设计步骤

#### 步骤1：整理测试观点
```markdown
## 测试观点列表

### 功能观点
- [ ] 正常输入的行为
- [ ] 输入值验证
- [ ] 错误处理
- [ ] 数据持久化

### 数据观点
- [ ] 边界值（最小、最大）
- [ ] 特殊字符/多语言
- [ ] NULL/空字符串
- [ ] 无效格式

### 状态观点
- [ ] 初始状态
- [ ] 数据存在状态
- [ ] 错误状态
- [ ] 受限状态

### 环境观点
- [ ] 正常环境
- [ ] 高负载环境
- [ ] 故障环境
```

#### 步骤2：创建测试用例矩阵

| 功能 | 正常 | 异常 | 边界值 | 安全 | 性能 |
|------|------|------|--------|------|------|
| 用户注册 | TC001 | TC002-006 | TC007 | TC010 | TC008 |
| 验证 | - | TC002-006 | TC004,005,007 | - | - |
| 数据保存 | TC001 | TC009 | - | - | - |

#### 步骤3：创建详细测试用例
- 将每个单元格的内容展开为详细的测试用例
- 分解为可执行的具体步骤
- 明确定义期望结果

### 3. AI辅助测试用例支持

#### AI可以利用的领域
- **覆盖性检查**：指出遗漏的测试用例
- **测试数据生成**：建议边界值和异常值
- **期望值计算**：计算复杂的计算结果
- **测试用例结构化**：统一格式

#### 需要人工判断的领域
- **业务需求理解**：领域特定需求
- **风险评估**：影响度和重要度判定
- **测试优先级**：执行顺序和资源分配
- **质量标准**：接受标准设定

## 测试用例质量检查要点

### 1. 完整性确认

#### 功能覆盖
```markdown
## 覆盖检查清单

### API规格书各项目
- [ ] 所有端点都有测试用例
- [ ] 所有参数都有测试用例
- [ ] 所有响应模式都有测试用例

### 错误处理
- [ ] 所有错误代码都有测试用例
- [ ] 所有验证规则都有测试用例
- [ ] 所有异常模式都有测试用例
```

#### 业务规则覆盖
```markdown
### 业务规则验证
- [ ] 所有业务流程都有测试用例
- [ ] 所有业务异常都有测试用例
- [ ] 所有权限模式都有测试用例
```

### 2. 可执行性确认

#### 测试数据准备可能性
- 能否准备必要的测试数据？
- 能否模拟外部依赖服务？
- 能否在测试环境中执行？

#### 期望结果可验证性
- 期望结果是否可以客观判定？
- 验证所需的工具或方法是否可用？
- 难以自动化部分的手动确认方法

### 3. 可维护性确认

#### 测试用例独立性
- 每个测试用例可以独立执行
- 不依赖测试顺序
- 可以并行执行

#### 变更应对
- 规格变更时影响范围明确
- 测试用例修改容易
- 测试数据管理简单

## 人工审查要点

### 审查观点

#### 1. 与业务需求的一致性
- [ ] 用户故事是否得到适当测试？
- [ ] 业务规则是否正确反映？
- [ ] 边缘情况从业务角度是否合理？

#### 2. 基于风险的优先级
- [ ] 高风险功能是否有充分的测试用例？
- [ ] 重要的业务流程是否被覆盖？
- [ ] 安全需求是否得到适当测试？

#### 3. 测试效率
- [ ] 测试用例数量是否适当（不多不少）？
- [ ] 是否有重复的测试用例？
- [ ] 可自动化部分和手动测试的分离是否适当？

### 审查流程

#### 步骤1：初步审查
- 确认与规格书的一致性
- 基本覆盖性检查
- 指出明显的遗漏或问题

#### 步骤2：详细审查
- 确认每个测试用例的有效性
- 确认期望结果的准确性
- 验证可执行性

#### 步骤3：最终批准
- 整体质量确认
- 确认测试执行计划
- 判定进入下一阶段

## 测试用例创建最佳实践

### 1. 逐步细化

```markdown
第1阶段：概述级别
"测试用户注册的正常和异常情况"

第2阶段：功能级别
"有效数据的注册成功"
"无效数据的注册失败"

第3阶段：详细级别
"TC001：正常用户注册"
"TC002：邮箱地址重复错误"
```

### 2. 战略性测试数据设计

#### 数据模式系统化
```markdown
## 基本数据集
- 正常数据：通用有效值
- 边界数据：限制值（最小/最大）
- 异常数据：无效值/错误值
- 特殊数据：特殊字符/多语言/NULL
```

#### 可重用测试数据
- 定义通用测试数据
- 管理测试数据变化
- 数据创建自动化

### 3. 期望结果的精确定义

#### 具体的期望值
```markdown
❌ "应该错误"
✅ "HTTP 400 + {"error": "validation_failed", "field": "email"}"

❌ "应该正常注册"
✅ "HTTP 201 + 返回用户ID + DB创建记录"
```

#### 可验证的条件
- 输出值的具体值或格式
- 数据库状态变化
- 日志输出内容
- 对外部系统的影响

## 常见问题和对策

### 问题1：测试用例粒度不当

**症状**：
- 一个测试用例测试多个功能
- 反之，过于细化导致管理成本高

**对策**：
- 一个测试用例 = 一个验证观点
- 按业务价值单位分组

### 问题2：期望结果模糊

**症状**：
- "应该正常工作"、"应该发生错误"等
- 判定标准不明确

**对策**：
- 明确具体值和状态
- 考虑自动测试的判定条件

### 问题3：测试用例遗漏

**症状**：
- 边缘情况未考虑
- 错误模式不足

**对策**：
- 通过检查清单进行系统性确认
- 利用等价类划分和边界值分析

### 问题4：可维护性不足

**症状**：
- 规格变更时测试用例修改困难
- 测试数据管理复杂

**对策**：
- 模块化设计
- 可重用测试数据设计

## 下一步准备

测试用例创建完成后，继续进行[Red-Green-Refactor-Validation循环](./04-rgr-validation-cycle.md)。

### 交付物确认
- [ ] testcases.md已详细创建
- [ ] 所有规格项目都有对应的测试用例
- [ ] 期望结果已具体定义
- [ ] 已完成人工审查
- [ ] 测试数据可以准备

### 质量检查清单
- [ ] **全面性**：覆盖正常、异常和边界情况
- [ ] **明确性**：期望结果具体且可验证
- [ ] **独立性**：每个测试用例可以独立执行
- [ ] **可行性**：可在测试环境中执行
- [ ] **可维护性**：易于应对规格变更的结构

通过适当的测试用例创建，为AI生成高质量代码奠定了基础。下一章将详细解释基于这些测试用例的实现循环。