# 2.2 Claude Sonnet 4の活用方法

AITDDの核心となるClaude Sonnet 4の効果的な活用方法について説明します。単にAIにコードを書かせるのではなく、人間とAIが協調して高品質なソフトウェアを開発する方法を学びます。

## Claude Sonnet 4の特徴と強み

### AITDDにおける位置づけ
- **Red-Green-Refactor-Validationサイクルの実行主体**
- **設計からテスト、実装まで一貫して担当**
- **高品質なコード生成と品質チェックを両立**

### 選択理由
- **アクセス性**: Claude Codeで自由に使用可能
- **コーディング性能**: 必要十分なレベルの安定した性能
- **コスト効率**: 妥当なレベルでのコスト（$20/月）
- **AITDD適性**: トライアル重視の開発スタイルに最適
- **統合性**: VS Code環境との優れた連携

## Claude Codeの基本的な使い方

### 起動と基本操作

1. **Claude Codeの起動**
   ```bash
   # VS Code内でClaude Codeを起動
   # またはブラウザ版Claude経由でアクセス
   ```

2. **プロジェクトとの連携**
   - プロジェクトディレクトリの指定
   - ファイル構造の認識
   - 既存コードの理解

### AITDDでの基本的な対話パターン

#### 1. ゴール設定フェーズ
```
あなた: "ユーザー管理機能のCRUD操作を実装したい。まずTODOリストを作成してください。"

Claude: "ユーザー管理機能のTODOリストを作成します：
1. ユーザーモデルの定義
2. ユーザー作成のテストケース作成
3. ユーザー作成機能の実装
..."
```

#### 2. テスト作成フェーズ
```
あなた: "TODOの最初の項目のテストケースを作成してください。"

Claude: "ユーザーモデルのテストケースを作成します：
```javascript
describe('User Model', () => {
  test('should create user with valid data', () => {
    // テストコード
  });
});
```"
```

#### 3. 実装フェーズ
```
あなた: "このテストを通すためのコードを実装してください。"

Claude: "テストを通すためのユーザーモデルを実装します：
```javascript
class User {
  constructor(name, email) {
    // 実装コード
  }
}
```"
```

## 効果的なプロンプト設計

### プロンプト設計の基本原則

#### 1. 明確な目標設定
**良い例:**
```
"ユーザー登録API（POST /users）を実装したい。
- バリデーション機能付き
- エラーハンドリング含む
- テストファーストで進めたい"
```

**悪い例:**
```
"ユーザー機能を作って"
```

#### 2. 文脈の提供
```
"現在のプロジェクト構成：
- Express.js + MongoDB
- Jest for testing
- 既存のUserモデルあり

新しく追加したい機能：
- ユーザーのプロフィール更新API"
```

#### 3. 制約の明示
```
"制約条件：
- 既存のAPIとの互換性を保つ
- セキュリティを考慮した実装
- パフォーマンス要件: 1秒以内のレスポンス"
```

### プロンプト最適化の反復プロセス

#### ステップ1: 初回実行
1. **プロンプトを作成**
2. **AIに実行依頼**
3. **結果を評価**

#### ステップ2: 評価と改善
1. **期待との差分を特定**
2. **プロンプトの問題点を分析**
3. **改善版プロンプトを設計**

#### ステップ3: 再実行
1. **改善されたプロンプトで実行**
2. **結果の改善度を確認**
3. **必要に応じてさらに調整**

### 実践的なプロンプトテンプレート

#### 機能実装用テンプレート
```
【実装依頼】
機能: [具体的な機能名]
技術スタック: [使用技術の列挙]
要件:
- [要件1]
- [要件2]
- [要件3]

制約:
- [制約1]
- [制約2]

期待する成果物:
- テストケース
- 実装コード
- ドキュメント（必要に応じて）
```

#### デバッグ用テンプレート
```
【デバッグ依頼】
問題: [具体的な問題の説明]
エラーメッセージ: [実際のエラー]
再現手順:
1. [手順1]
2. [手順2]
3. [手順3]

関連コード: [問題のあるコード]
期待する動作: [本来の動作]
```

## レビューと品質管理

### 人力レビューのポイント

#### 1. 仕様との整合性確認
- **設計意図の反映**: 計画した機能が正しく実装されているか
- **要件の網羅**: すべての要件が満たされているか
- **制約の遵守**: 設定した制約が守られているか

#### 2. レビュー対象の優先順位
1. **仕様書**: 要件との整合性が最重要
2. **テストケース**: 仕様の適切なカバレッジ
3. **実装コード**: コード品質と仕様適合性

#### 3. レビューチェックリスト
- [ ] 機能要件が満たされているか
- [ ] エラーハンドリングが適切か
- [ ] セキュリティ要件が考慮されているか
- [ ] パフォーマンス要件が満たされているか
- [ ] テストカバレッジが十分か
- [ ] コードの可読性・保守性は良いか

### AIが期待通りの結果を出さない場合の対処法

#### フォールバック戦略

**基本対応フロー:**
1. **git reset**: 前の状態に戻す
2. **プロンプト調整**: 指示を明確化・詳細化
3. **再実行**: 同じツール（Claude Sonnet 4）で再試行
4. **評価**: 結果の改善度を確認

**git resetのタイミング:**
- 最終コードが期待から大きくズレた場合
- 修正依頼より作り直しの方が早いと判断した場合
- 複数回の修正試行で改善が見られない場合

#### プロンプト調整のテクニック

**具体性の向上:**
```
# 改善前
"このコードを修正して"

# 改善後
"このコードの以下の問題を修正して：
1. バリデーションエラーが適切に処理されていない
2. 戻り値の型が仕様と異なる
3. エッジケースのテストが不足している"
```

**文脈の追加:**
```
# 改善前
"APIを作って"

# 改善後
"Express.jsを使用してRESTful APIを作成：
- エンドポイント: POST /api/users
- リクエスト形式: JSON
- レスポンス形式: JSON
- 既存のUserモデルを使用
- MongoDB Atlas接続済み"
```

## 継続的改善のための記録

### 成功パターンの記録
```markdown
## 成功事例記録

### 日付: 2025-06-21
### タスク: ユーザー認証API実装
### 使用したプロンプト:
[具体的なプロンプト内容]

### 結果:
- 一発で期待通りの実装完了
- テストも100%通過

### 学び:
- 認証系は具体的なライブラリ指定が効果的
- セキュリティ要件を事前に明示することが重要
```

### 失敗パターンの分析
```markdown
## 改善事例記録

### 日付: 2025-06-21
### タスク: 複雑なクエリ最適化
### 問題:
- 最初の実装がパフォーマンス要件を満たさず
- 3回の修正試行でも改善されず

### 解決策:
- git resetで初期状態に戻す
- プロンプトにパフォーマンス要件を数値で明示
- 参考実装例を提供

### 学び:
- 性能要件は定量的に指定する
- 複雑なタスクは小さく分割する
```

## Claude Sonnet 4以外のツールとの使い分け

### Gemini（調査用）との詳細な連携

#### Geminiの使用場面と強み
**使用場面:**
- 新しいライブラリの調査
- 技術文書の大量読み込み
- 長いコンテキストを要求される調査タスク
- 複数の情報源からの情報統合

**Geminiの固有の強み:**
- **長いコンテキスト**: 大量の情報を一度に処理可能
- **情報収集能力**: 複数のソースからの情報を効果的に統合
- **調査特化**: 技術情報の深堀りに優れた性能

#### 実践的な連携ワークフロー

**基本的な連携パターン:**
```
1. 調査課題の特定 → Gemini による情報収集
2. 情報の整理・要約 → Gemini による分析
3. 実装計画の立案 → Claude Sonnet 4 に情報提供
4. AITDD実行 → Claude Sonnet 4 による一貫した実装
```

**連携の具体例:**

**例1: 新しいフレームワーク導入**
```
Gemini:
"Next.js 14の新機能について調査し、既存のExpress.js
アプリケーションからの移行方法を整理してください"

↓ 調査結果をClaude Sonnet 4に提供

Claude Sonnet 4:
"Geminiの調査結果を基に、段階的な移行計画のTODOリストを
作成し、AITDDで最初の機能を実装してください"
```

**例2: 技術仕様の深掘り調査**
```
Gemini:
"OAuth 2.0とJWT認証の組み合わせについて、セキュリティの
ベストプラクティスと実装パターンを調査してください"

↓ セキュリティ要件を整理してClaude Sonnet 4に提供

Claude Sonnet 4:
"調査結果に基づき、セキュアな認証システムのテストケースから
作成し、AITDD手法で実装してください"
```

#### 使い分けの判断基準

**Geminiを使うべき場面:**
- [ ] 新技術・新ライブラリの初回調査
- [ ] 複数の選択肢の比較検討が必要
- [ ] 長い技術文書の読み込みが必要
- [ ] 複雑な要件の整理が必要
- [ ] 先行事例の調査が必要

**Claude Sonnet 4を使うべき場面:**
- [ ] 具体的な実装作業
- [ ] テストケースの作成
- [ ] コードレビューと品質チェック
- [ ] デバッグとトラブルシューティング
- [ ] リファクタリング作業

### 実践的な運用ノウハウ

#### プロンプト設計の発展的テクニック

**コンテキスト継続の技術:**
```
# セッション開始時
"以下のプロジェクト構成を記憶してください：
- Express.js + MongoDB + Jest
- ユーザー認証機能実装済み
- 今回の目標：ユーザープロフィール管理機能の追加"

# 継続セッションでの参照
"先ほど伝えたプロジェクト構成を前提に、
プロフィール更新APIのテストケースを作成してください"
```

**段階的詳細化の技術:**
```
# フェーズ1: 概要レベル
"ユーザー管理システムの全体設計を考えてください"

# フェーズ2: 機能レベル
"先ほどの設計から、プロフィール更新機能の詳細仕様を作成してください"

# フェーズ3: 実装レベル
"仕様を基に、テストケースとAPIエンドポイントを実装してください"
```

#### エラー対応の発展的戦略

**プロンプト調整のパターン分析:**

**パターン1: 具体性不足による失敗**
```
# 失敗例
"APIを作って"
→ 期待と大きく異なる実装

# 成功例
"Express.jsでPOST /api/users/profile APIを作成:
- リクエスト: {name, email, bio}
- バリデーション: emailフォーマット、name必須
- レスポンス: 更新されたユーザー情報
- エラーハンドリング: 400, 401, 500対応"
```

**パターン2: 技術制約の未指定による失敗**
```
# 失敗例
"データベース操作のコードを書いて"
→ 使用していないORMでの実装

# 成功例
"Mongoose 7.x を使用してUserスキーマの更新操作を実装:
- 既存のUserモデルを使用
- findByIdAndUpdate メソッドを使用
- バリデーションエラーの適切な処理"
```

**プロンプト調整の実践的チェックリスト:**
- [ ] 使用技術スタックの明示
- [ ] 入出力形式の具体的な指定
- [ ] エラーケースの考慮指示
- [ ] 既存コードとの整合性確保
- [ ] パフォーマンス要件の明示
- [ ] セキュリティ考慮事項の指示

#### 継続的改善のための記録方法

**成功パターンのテンプレート化:**
```markdown
## プロンプトテンプレート: API実装

### 基本形式
"[フレームワーク名]で[HTTPメソッド] [エンドポイント] APIを実装:
- リクエスト形式: [詳細]
- レスポンス形式: [詳細]
- バリデーション: [要件]
- エラーハンドリング: [対応するステータスコード]
- 既存の[モデル名]モデルを使用"

### 適用例
[具体的な使用例]

### 期待される結果
[成功時の出力パターン]
```

**失敗パターンの分析記録:**
```markdown
## 改善記録: [日付]

### 問題のあったプロンプト
[元のプロンプト]

### 発生した問題
- [具体的な問題1]
- [具体的な問題2]

### 改善後のプロンプト
[修正版プロンプト]

### 改善のポイント
- [改善点1]
- [改善点2]

### 今後の適用指針
[他のケースへの応用方法]
```

### 他のAIツールとの比較の詳細

**なぜClaude Sonnet 4に集約するか:**

**1. 一貫性の重要性**
- 同じツールによる統一されたアプローチ
- 学習した最適化が累積的に効果を発揮
- ツール固有の癖や制限への対応が蓄積される

**2. 学習効率の最大化**
- 一つのツールに習熟することで効率向上
- プロンプト設計のノウハウが深化
- エラーパターンと対処法の蓄積

**3. コスト管理の簡素化**
- 複数ツールより単一ツールが管理しやすい
- 予算計画の簡素化
- 使用量監視の一元化

**4. フォールバック戦略の簡潔性**
- 複雑な判断ロジックを避けられる
- 「どのツールで再試行するか」の判断が不要
- 迅速な問題解決が可能

**ツール統合によるメリット:**
```
項目               Claude Sonnet 4    他ツール
──────────────────────────────────────────
学習コスト         低                高
プロンプト最適化効率 高                低
コスト管理複雑度   低                高
フォールバック判断 シンプル          複雑
ナレッジ蓄積効率   高                分散
──────────────────────────────────────────
総合的な開発効率   最適化            非効率
```

### AIツール環境の将来対応

#### 新技術への対応方針
**評価基準の体系化:**
- **性能評価**: 既存ワークフローでの性能比較
- **コスト分析**: 総所有コスト（学習コスト含む）の評価
- **統合性評価**: 現在の開発環境との親和性
- **移行コスト**: ツール変更に伴うコストの見積もり

**段階的導入アプローチ:**
1. **情報収集期**: 3-6ヶ月の観察期間
2. **小規模テスト**: 非重要プロジェクトでの試用
3. **比較評価**: 定量的な性能・効率比較
4. **段階的移行**: 明確な優位性確認後の慎重な移行

**判断の定量化:**
```
新ツール採用の閾値:
- 性能向上: 20%以上
- コスト削減: 15%以上
- 学習コスト: 2週間以内
- 統合コスト: 現在ツールの50%以下
```

## 次のステップ

Claude Sonnet 4の活用方法を理解したら、次の章「2.3 開発環境とワークフロー構築」で、AITDDを実践するための総合的な開発環境を構築しましょう。TODO管理からGitワークフローまで、体系的な開発プロセスを確立します。